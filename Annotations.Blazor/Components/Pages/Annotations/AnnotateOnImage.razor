@rendermode InteractiveServer
@page "/images/annotations"
@using System.Text.Json
@using Home
@implements IDisposable
@inject NavigationManager Navigation
@inject IAPIServices IapiServices
@attribute [Authorize(Roles = "Administrator, Manager, AnnotationsUser")]



<PageTitle>Annotations</PageTitle>
<AuthorizeView>
    <Authorized>
        <MatThemeProvider Theme="@_theme">
            <MatDialog @bind-IsOpen="@_showCompletionDialog">
                <MatDialogTitle>@_completionTitle</MatDialogTitle>
                <MatDialogContent>@_completionMessage</MatDialogContent>
                <MatDialogActions>
                    <MatButton OnClick="@(() => _showCompletionDialog = false)">OK</MatButton>
                </MatDialogActions>
            </MatDialog>

            <MatDialog @bind-IsOpen="@_showTextField">
                <MatDialogTitle>Blood vessel point annotation</MatDialogTitle>
                <MatDialogContent>
                    <p>
                        <MatTextField @bind-Value="_currentPoint!.Text"
                                      Label="Annotation"
                                      FullWidth="true"
                                      Immediate="true"
                                      Id="annotationTextField"
                                      class="MatOverwriteWhiteBG">
                        </MatTextField>
                    </p>
                    <p>
                        <MatSelectItem @bind-Value="@_currentPoint.Type" Label="Type" Items="@_types"></MatSelectItem>
                    </p>
                </MatDialogContent>
                <MatDialogActions>
                    <div>
                        <MatButton class="MatOverwriteButton" OnClick="SavePointAnnotation">Save</MatButton>
                        <MatButton class="MatOverwriteButton" OnClick="CancelPointAnnotation">Cancel</MatButton>
                    </div>
                </MatDialogActions>
            </MatDialog>

            <MatDialog @bind-IsOpen="_showSegmentDialog">
                <MatDialogTitle>Blood vessel segment annotation</MatDialogTitle>
                <MatDialogContent>
                    <p>
                        <MatTextField @bind-Value="_currentSegment!.Text"
                                      Label="Annotation"
                                      FullWidth="true"
                                      Immediate="true"
                                      class="MatOverwriteWhiteBG">
                        </MatTextField>
                    </p>
                    <p>
                        <MatTextField @bind-Value="_currentSegment.Thickness"
                                      Label="Blood vessel thickness"
                                      FullWidth="true"
                                      Immediate="true"
                                      class="MatOverwriteWhiteBG">
                        </MatTextField>
                    </p>
                    <p>
                        <MatSelectItem @bind-Value="@_currentSegment.Type" Label="Type" Items="@_types"></MatSelectItem>
                    </p>
                </MatDialogContent>
                <MatDialogActions>
                    <div>
                        <MatButton class="MatOverwriteButton" OnClick="SaveSegmentAnnotation">Save</MatButton>
                        <MatButton class="MatOverwriteButton" OnClick="CancelSegmentAnnotation">Cancel</MatButton>
                    </div>
                </MatDialogActions>
            </MatDialog>

            <div class="mat-layout-grid">
                <div class="mat-layout-grid-inner">
                    <div class="mat-layout-grid-cell mat-layout-grid-cell-span-2">
                        <div class="MatOverwriteGrid">
                            <img src="img/billede1.png" alt="Profile Picture" class="MatOverwriteProfilePic">
                            <div>
                                <b>Jane Doe</b>
                                <br/>
                                <small>Surgeon</small>
                            </div>
                        </div>
                        <div class="MatOverwriteMarginTop50">
                            <MatCheckbox @bind-Value="@_arteriesMarked">Arteries marked</MatCheckbox>
                        </div>
                        <div>
                            <MatCheckbox @bind-Value="@_veinsMarked">Veins marked</MatCheckbox>
                        </div>
                        <div>
                            <MatCheckbox @bind-Value="@_flowDirectionSet">Flow direction set</MatCheckbox>
                        </div>
                        <div>
                            <MatCheckbox @bind-Value="@_videoReviewed">Video reviewed</MatCheckbox>
                        </div>
                    </div>
                    <div class="mat-layout-grid-cell mat-layout-grid-cell-span-10">
                        <div class="mat-layout-grid-inner">
                            <div class="mat-layout-grid-cell mat-layout-grid-cell-span-3">
                                <div class="MatOverwriteIdentification">
                                    <MatTabGroup>
                                        <MatTab Label="Vessels">
                                            <div class="MatOverwritePadding16">
                                                <b>Blood Vessel Identification</b>
                                            </div>
                                        </MatTab>
                                        <MatTab Label="Flow">
                                            <div class="MatOverwritePadding16">
                                                <b>Blood Flow Identification</b>
                                            </div>
                                        </MatTab>
                                        <MatTab Label="Organs">
                                            <div class="MatOverwritePadding16">
                                                <b>Organ Identification</b>
                                            </div>
                                        </MatTab>
                                    </MatTabGroup>
                                </div>
                            </div>
                            <div class="mat-layout-grid-cell mat-layout-grid-cell-span-9 mat-layout-grid-align-right">
                                <div class="MatOverwriteDecisions">
                                    <MatButton>Skip</MatButton>
                                    <MatButton OnClick="CompleteCurrentVessel" class="MatOverwriteButton">Complete</MatButton>
                                </div>
                            </div>
                        </div>

                        <div class="MatOverwriteRelative" @ref="_imageContainer">
                            <img src="img/Skærmbillede%202025-03-27%20kl.%2014.05.56.png" alt="Annotation Image" 
                                 @onclick="HandleImageClick" class="MatOverwriteWorkImage"/>

                            <svg @onpointermove="HandleDrag"
                                 @onpointerup="EndDrag"
                                 @onpointerleave="EndDrag"
                                 class="MatOverwriteSVG">

                                @foreach (var segment in _drawableSegments)
                                {
                                    <line x1="@segment.StartPoint!.X" y1="@segment.StartPoint.Y"
                                          x2="@segment.EndPoint!.X" y2="@segment.EndPoint.Y"
                                          stroke="transparent"
                                          stroke-width="20"
                                          @onclick="@(() => HandleSegmentClick(segment))"
                                          pointer-events="visibleStroke"/>

                                    <line x1="@segment.StartPoint.X" y1="@segment.StartPoint.Y"
                                          x2="@segment.EndPoint.X" y2="@segment.EndPoint.Y"
                                          stroke="white"
                                          stroke-width="2"
                                          pointer-events="none"/>
                                }

                                @foreach (var point in _drawablePoints)
                                {
                                    <circle cx="@point.X" cy="@point.Y" r="10"
                                            fill="white" stroke="white"
                                            stroke-width="2"
                                            @onpointerdown="@(e => StartDrag(e, point))"
                                            class="MatOverwriteCursor"/>
                                }

                                @if (_currentVesselAnnotation != null)
                                {
                                    if (_currentVesselAnnotation.Segments != null)
                                    {
                                        @foreach (var segment in _currentVesselAnnotation.Segments)
                                        {
                                            <line x1="@segment.StartPoint!.X" y1="@segment.StartPoint.Y"
                                                  x2="@segment.EndPoint!.X" y2="@segment.EndPoint.Y"
                                                  stroke="transparent"
                                                  stroke-width="20"
                                                  @onclick="@(() => HandleSegmentClick(segment))"
                                                  pointer-events="visibleStroke"/>

                                            <line x1="@segment.StartPoint.X" y1="@segment.StartPoint.Y"
                                                  x2="@segment.EndPoint.X" y2="@segment.EndPoint.Y"
                                                  stroke="white"
                                                  stroke-width="2"
                                                  pointer-events="none"/>
                                        }
                                    }

                                    if (_currentVesselAnnotation.Points != null)
                                    {
                                        @foreach (var point in _currentVesselAnnotation.Points)
                                        {
                                            <circle cx="@point!.X" cy="@point.Y" r="10"
                                                    fill="white" stroke="white"
                                                    stroke-width="2"
                                                    @onpointerdown="@(e => StartDrag(e, point))"
                                                    class="MatOverwriteCursor"/>
                                        }
                                    }
                                }
                            </svg>
                        </div>
                    </div>
                </div>
            </div>
        </MatThemeProvider>
    </Authorized>
    <NotAuthorized>
        <Home/>
    </NotAuthorized>
</AuthorizeView>

@code {
    private string? _currentUrl;
    private bool _arteriesMarked;
    private bool _veinsMarked;
    private bool _flowDirectionSet;
    private bool _videoReviewed;

    private bool _showCompletionDialog;
    private string _completionMessage = "";
    private string _completionTitle = "";

    private bool _showTextField;
    private bool _showSegmentDialog;
    
    private string _currentImagePath = "img/Skærmbillede%202025-03-27%20kl.%2014.05.56.png";

    private VesselPointModel? _draggedPoint;
    private VesselPointModel? _currentPoint = new VesselPointModel
    {
        Id = 0,
        X = 0,
        Y = 0,
        Text = "",
        Type = ""
    }; //maybe issue here
    private VesselSegmentModel? _currentSegment = new VesselSegmentModel
    {
        Id = 0,
        StartPoint = null!,
        EndPoint = null!,
        Text = "",
        Thickness = 0,
        Type = ""
    }; //here

    private VesselAnnotationModel? _currentVesselAnnotation = new()
    {
        Id = 0,
        ImagePath = "",
        Points = new(),
        Segments = new(),
        Description = "",
        Type = ""
    }; //here
    private List<VesselAnnotationModel>? _savedVessels = new();

    private List<VesselSegmentModel> _drawableSegments = new();
    private List<VesselPointModel> _drawablePoints = new();

    private string _currentVesselType = "";
    private double _currentThickness = 0.0;

    private ElementReference _imageContainer;

    private string[] _types =
    [
        "Artery",
        "Vein",
        "Flow direction"
    ];

    MatTheme _theme = new MatTheme()
    {
        Primary = MatThemeColors.Green._800.Value
    };

    protected override async Task OnInitializedAsync()
    {
        _currentUrl = Navigation.Uri;
        Navigation.LocationChanged += OnLocationChanged;
        
        await LoadAnnotationsForImage(_currentImagePath);
    }

    private void OnLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        _currentUrl = Navigation.Uri;
        StateHasChanged();
    }
    
    private async Task LoadAnnotationsForImage(string imagePath)
    {
        try
        {
            var response = await IapiServices.CreateGetResponse($"/images/annotations?imagePath={Uri.EscapeDataString(imagePath)}");
            if (response.IsSuccessStatusCode)
            {
                var options = new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                };
            
                var content = await response.Content.ReadAsStringAsync();
                _savedVessels = JsonSerializer.Deserialize<List<VesselAnnotationModel>>(content, options);
                PrecomputeAnnotations();
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading annotations: {ex.Message}");
        }
    }
    
    private void HandleSegmentClick(VesselSegmentModel segment)
    {
        _currentSegment = segment;
        _showSegmentDialog = true;

        StateHasChanged();
    }

    public void Dispose() => Navigation.LocationChanged -= OnLocationChanged;

    private void PrecomputeAnnotations()
    {
        _drawableSegments.Clear();
        _drawablePoints.Clear();

        foreach (var vessel in _savedVessels!)
        {
            if (vessel.Segments != null)
            {
                _drawableSegments.AddRange(vessel.Segments);
            }

            if (vessel.Points != null)
            {
                _drawablePoints.AddRange(vessel.Points.Where(point => point != null).Cast<VesselPointModel>());
            }
        }
    }

    private void SavePointAnnotation()
    {
        if (_currentVesselAnnotation != null)
        {
            _currentVesselAnnotation.Points.Add(_currentPoint!);

            if (_currentVesselAnnotation.Points.Count > 1)
            {
                var lastPoint = _currentVesselAnnotation.Points[^2];
                var segment = new VesselSegmentModel
                {
                    Id = 0,
                    StartPoint = lastPoint,
                    EndPoint = _currentPoint!,
                    Type = _currentVesselType,
                    Thickness = _currentThickness,
                    Text = _currentPoint!.Text
                };
                _currentVesselAnnotation.Segments.Add(segment);
            }
        }

        _showTextField = false;
        StateHasChanged();
        PrecomputeAnnotations();
    }

    private void CancelPointAnnotation()
    {
        _showTextField = false;
        StateHasChanged();
    }

    private void SaveSegmentAnnotation()
    {
        _showSegmentDialog = false;
        StateHasChanged();
        PrecomputeAnnotations();
    }

    private void CancelSegmentAnnotation()
    {
        _showSegmentDialog = false;
        StateHasChanged();
    }

    private async Task CompleteCurrentVessel()
    {
        if (_currentVesselAnnotation?.Points.Count < 2)
        {
            _completionTitle = "Fail";
            _completionMessage = "Your blood vessel tree needs at least two annotations";
            _showCompletionDialog = true;
            StateHasChanged();
            return;
        }

        await SaveAnnotationToDb(_currentVesselAnnotation!);
        
        _currentVesselAnnotation = new VesselAnnotationModel
        {
            Id = 0,
            ImagePath = "",
            Points = new(),
            Segments = new(),
            Description = "",
            Type = ""
        };

        _completionTitle = "Success";
        _completionMessage = "Your blood vessel tree has been successfully completed";
        _showCompletionDialog = true;
        StateHasChanged();

        PrecomputeAnnotations();
    }

    private async Task SaveAnnotationToDb(VesselAnnotationModel vessel)
    {
        vessel.ImagePath = _currentImagePath;
        //try
        //{
        var response = await IapiServices.CreatePostRequest($"/images/annotations/save", vessel); //sending the response
        if (!response.IsSuccessStatusCode)
        {
            Console.WriteLine("Error with post request for Annotation");
        }
        else
        {
            _savedVessels!.Add(_currentVesselAnnotation!);
            await LoadAnnotationsForImage(_currentImagePath);
        }
        //}
        //catch
        //{
        //error handling?
        //}
    }
    
    private async Task HandleImageClick(MouseEventArgs e)
    {
        var rect = await JsRuntime.InvokeAsync<BoundingClientRect>(
            "getBoundingClientRect", _imageContainer);

        _currentPoint = new VesselPointModel
        {
            Id = 0, //arbitrary
            X = (int)(e.ClientX - rect.Left),
            Y = (int)(e.ClientY - rect.Top),
            Type = _currentVesselType,
            Text = ""
        };

        _showTextField = true;
        StateHasChanged();
    }

    private void StartDrag(PointerEventArgs e, VesselPointModel point)
    {
        _draggedPoint = point;
    }

    private async Task HandleDrag(PointerEventArgs e)
    {
        if (_draggedPoint == null) return;

        var rect = await JsRuntime.InvokeAsync<BoundingClientRect>(
            "getBoundingClientRect", _imageContainer);

        _draggedPoint.X = (int)(e.ClientX - rect.Left);
        _draggedPoint.Y = (int)(e.ClientY - rect.Top);

        StateHasChanged();
    }

    private void EndDrag() => _draggedPoint = null;

    private struct BoundingClientRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
    }

    [Inject] private IJSRuntime JsRuntime { get; set; } = default!;
}