@* @page "/images/{imageid}/annotations" *@
@rendermode InteractiveServer
@page "/images/annotations"
@using Home
@implements IDisposable
@inject NavigationManager Navigation
@attribute [Authorize(Roles = "Administrator, Manager, AnnotationsUser")]



<PageTitle>Annotations</PageTitle>
<AuthorizeView>
    <Authorized>
        <MatThemeProvider Theme="@_theme">
            <MatDialog @bind-IsOpen="@_showCompletionDialog">
                <MatDialogTitle>@_completionTitle</MatDialogTitle>
                <MatDialogContent>@_completionMessage</MatDialogContent>
                <MatDialogActions>
                    <MatButton OnClick="@(() => _showCompletionDialog = false)">OK</MatButton>
                </MatDialogActions>
            </MatDialog>
            
            <MatDialog @bind-IsOpen="@_showTextField">
                <MatDialogTitle>Blood vessel annotation</MatDialogTitle>
                <MatDialogContent>
                    <p>
                        <!-- the position is auto focused on click position. Bound to currentAnnotation object --->
                        <MatTextField @bind-Value="_currentPoint!.Text"
                                      Label="Annotation"
                                      FullWidth="true"
                                      Immediate="true"
                                      Id="annotationTextField"
                                      Style="background: white">
                        </MatTextField>
                    </p>
                    <p>
                        <MatSelectItem @bind-Value="@_currentPoint.Type" Label="Type" Items="@_types"></MatSelectItem>
                    </p>
                </MatDialogContent>
                <MatDialogActions>
                    <div>
                        <MatButton OnClick="SaveAnnotation" Style="color: white; background: #101e2d">Save</MatButton>
                        <MatButton OnClick="CancelAnnotation" Style="color: white; background: #101e2d">Cancel</MatButton>
                    </div>
                </MatDialogActions>
            </MatDialog>
            
            <MatDialog @bind-IsOpen="_showThicknessDialog">
                <MatDialogTitle>Set blood vessel thickness</MatDialogTitle>
                <MatDialogContent>
                    <MatSlider @bind-Value="_currentThickness" Min="1" Max="5" Step="0.1"
                               Label="Thickness" Pin="true" Markers="true" Discrete="true" Style="width: 100%;"></MatSlider>
                </MatDialogContent>
            </MatDialog>
            
            <div class="mat-layout-grid">
                <div class="mat-layout-grid-inner">
                    <div class="mat-layout-grid-cell mat-layout-grid-cell-span-2">
                        <div style="display: flex; align-items: center; gap: 20px;">
                            <img src="img/billede1.png" alt="Profile Picture" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover;">
                            <div>
                                <b style="margin: 0;">Jane Doe</b>
                                <br/>
                                <small style="margin: 0;">Surgeon</small>
                            </div>
                        </div>
                        <div style="margin-top: 50px">
                            <MatCheckbox @bind-Value="@_arteriesMarked">Arteries marked</MatCheckbox>
                        </div>
                        <div>
                            <MatCheckbox @bind-Value="@_veinsMarked">Veins marked</MatCheckbox>
                        </div>
                        <div>
                            <MatCheckbox @bind-Value="@_flowDirectionSet">Flow direction set</MatCheckbox>
                        </div>
                        <div>
                            <MatCheckbox @bind-Value="@_videoReviewed">Video reviewed</MatCheckbox>
                        </div>
                    </div>
                    <div class="mat-layout-grid-cell mat-layout-grid-cell-span-10">
                        <div class="mat-layout-grid-inner">
                            <div class="mat-layout-grid-cell mat-layout-grid-cell-span-3">
                                <div style="display: flex; justify-content: flex-start; gap: 8px;">
                                    <MatTabGroup>
                                        <MatTab Label="Vessels">
                                            <div style="padding: 16px;">
                                                <b>Blood Vessel Identification</b>
                                            </div>
                                        </MatTab>
                                        <MatTab Label="Flow">
                                            <div style="padding: 16px;">
                                                <b>Blood Flow Identification</b>
                                            </div>
                                        </MatTab>
                                        <MatTab Label="Organs">
                                            <div style="padding: 16px;">
                                                <b>Organ Identification</b>
                                            </div>
                                        </MatTab>
                                    </MatTabGroup>
                                </div>
                            </div>
                            <div class="mat-layout-grid-cell mat-layout-grid-cell-span-9 mat-layout-grid-align-right" style="display: flex; margin-left: auto; gap: 8px;">
                                <div style="display: flex; justify-content: flex-end; gap: 8px;">
                                    <MatButton>Skip</MatButton>
                                    <MatButton OnClick="CompleteCurrentVessel" Style=" color: white; background: #101e2d">Complete</MatButton>
                                </div>
                            </div>
                        </div>
                        
                        <!-- @ref imageContainer captures the DOM element for position calculations, when annotating --->
                        <div style="position: relative;" @ref="_imageContainer">
                            <img src="img/SkÃ¦rmbillede%202025-03-27%20kl.%2014.05.56.png" alt="Annotation Image"
                                 @onclick="HandleImageClick"
                                 style="width: 1000px; height: 600px; pointer-events: auto"/>

                            <svg @onpointermove="HandleDrag"
                                 @onpointerup="EndDrag"
                                 @onpointerleave="EndDrag"
                                 style="position: absolute; left: 0; top: 0; width: 100%; height: 100%; pointer-events: none">
                                
                                @foreach (var vessel in _savedVessels)
                                {
                                    @foreach (var segment in vessel.Segments)
                                    {
                                        <line x1="@segment.StartPoint.X" y1="@segment.StartPoint.Y"
                                              x2="@segment.EndPoint.X" y2="@segment.EndPoint.Y"
                                              stroke="transparent"
                                              stroke-width="20"
                                              @onclick="@(() => HandleSegmentClick(segment))"
                                              pointer-events="visibleStroke"/>

                                        <!-- Visible line (on top) -->
                                        <line x1="@segment.StartPoint.X" y1="@segment.StartPoint.Y"
                                              x2="@segment.EndPoint.X" y2="@segment.EndPoint.Y"
                                              stroke="white"
                                              stroke-width="@(segment.Thickness * 2)"
                                              pointer-events="none"/>
                                    }

                                    @foreach (var point in vessel.Points)
                                    {
                                        <circle cx="@point.X" cy="@point.Y" r="8" fill="white"/>
                                    }
                                }

                                @if (_currentVesselAnnotation != null)
                                {
                                    @foreach (var segment in _currentVesselAnnotation.Segments)
                                    {
                                        <line x1="@segment.StartPoint.X" y1="@segment.StartPoint.Y"
                                              x2="@segment.EndPoint.X" y2="@segment.EndPoint.Y"
                                              stroke="transparent"
                                              stroke-width="20"
                                              @onclick="@(() => HandleSegmentClick(segment))"
                                              pointer-events="visibleStroke"/>

                                        <!-- Visible line (on top) -->
                                        <line x1="@segment.StartPoint.X" y1="@segment.StartPoint.Y"
                                              x2="@segment.EndPoint.X" y2="@segment.EndPoint.Y"
                                              stroke="white"
                                              stroke-width="@(segment.Thickness * 2)"
                                              pointer-events="none"/>
                                    }

                                    @foreach (var point in _currentVesselAnnotation.Points)
                                    {
                                        <circle cx="@point.X" cy="@point.Y" r="10"
                                                fill="white"
                                                stroke="white" stroke-width="2"
                                                @onpointerdown="@(e => StartDrag(e, point))"
                                                style="cursor: move; pointer-events: all" />
                                    }
                                }
                            </svg>
                        </div>
                    </div>
                </div>
            </div>
        </MatThemeProvider>
    </Authorized>
    <NotAuthorized>
        <Home/>
    </NotAuthorized>
</AuthorizeView>


@code {
    private string? _currentUrl;
    private bool _arteriesMarked;
    private bool _veinsMarked;
    private bool _flowDirectionSet;
    private bool _videoReviewed;

    private string[] _types =
    [
        "Artery",
        "Vein",
        "Flow direction"
    ];
    
    MatTheme _theme = new MatTheme()
    {
        Primary = MatThemeColors.Green._800.Value
    };
    
    protected override void OnInitialized()
    {
        _currentUrl = Navigation.Uri;
        Navigation.LocationChanged += OnLocationChanged;
        _currentVesselAnnotation = new VesselAnnotation();
        _currentPoint = new VesselPoint();
    }

    private void OnLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        _currentUrl = Navigation.Uri;
        StateHasChanged();
    }

    public void Dispose() => Navigation.LocationChanged -= OnLocationChanged;
    
    private class VesselPoint
    {
        public int X { get; set; }
        public int Y { get; set; }
        public string Text { get; set; } = "";
        public string Type { get; set; }
    }

    private class VesselSegment
    {
        public VesselPoint? StartPoint { get; set; }
        public VesselPoint? EndPoint { get; set; }
        public string? Type { get; set; }
        public double Thickness { get; set; } = 1.0;
        public string Text { get; set; } = "";
    }
    
    private class VesselAnnotation
    {
        public List<VesselPoint?> Points { get; } = new();
        public List<VesselSegment> Segments { get; } = new();
    }

    private VesselAnnotation? _currentVesselAnnotation;
    private VesselPoint? _currentPoint;
    private List<VesselAnnotation?> _savedVessels = new();
    private bool _showTextField = false;
    private string _currentVesselType = ""; // TODO: needs implementation
    private double _currentThickness = 1.0;
    
    private ElementReference _imageContainer;
    
    private bool _showCompletionDialog = false;
    private string _completionMessage = "";
    private string _completionTitle = "";
    private bool _showThicknessDialog = false;
    
    private VesselPoint? _draggedPoint;
    
    /*private VesselAnnotation _currentVesselAnnotation = new();
    private List<VesselAnnotation> savedAnnotations = new(); */

    private async Task HandleImageClick(MouseEventArgs e)
    {
        // Reset for new annotation currentVesselAnnotation = new VesselAnnotation();
        
        // Get click position relative to container
        var rect = await JsRuntime.InvokeAsync<BoundingClientRect>(
            "getBoundingClientRect", 
            _imageContainer
        );
        
        _currentPoint = new VesselPoint
        {
            X = (int)(e.ClientX - rect.Left),
            Y = (int)(e.ClientY - rect.Top),
            Type = _currentVesselType
        };
        
        _showTextField = true;
        StateHasChanged();
        
        /*
        // gets X and Y coordinates of click
        currentVesselAnnotation.X = (int)(e.ClientX - rect.Left);
        currentVesselAnnotation.Y = (int)(e.ClientY - rect.Top);
        
        StateHasChanged();
        */
    }

    private void SaveAnnotation()
    {
        // Add the current point to the vessel
        _currentVesselAnnotation.Points.Add(_currentPoint);
    
        // If we have at least 2 points, create segments
        if (_currentVesselAnnotation.Points.Count > 1)
        {
            var lastPoint = _currentVesselAnnotation.Points[^2]; // Second-to-last point
            var segment = new VesselSegment
            {
                StartPoint = lastPoint,
                EndPoint = _currentPoint,
                Type = _currentVesselType,
                Thickness = _currentThickness,
                Text = _currentPoint.Text
            };
            _currentVesselAnnotation.Segments.Add(segment);
        }
        
        _showTextField = false;
        StateHasChanged();
    }

    private void CancelAnnotation()
    {
        // Only clear if no points have been saved yet
        if (_currentVesselAnnotation.Points.Count == 0)
        {
            _currentVesselAnnotation = null;
        }
        _showTextField = false;
        StateHasChanged();
    }
    
    private void CompleteCurrentVessel()
    {
        if (_currentVesselAnnotation.Points.Count >= 2)
        {
            _savedVessels.Add(_currentVesselAnnotation);
            _currentVesselAnnotation = new VesselAnnotation();
            _completionTitle = "Success";
            _completionMessage = "Your blood vessel tree has been successfully completed";
            _showCompletionDialog = true;
            StateHasChanged();
        }
        else
        {
            _completionTitle = "Fail";
            _completionMessage = "Your blood vessel tree needs at least two annotations";
            _showCompletionDialog = true;
            StateHasChanged();
        }
    }

    private void HandleSegmentClick(VesselSegment segment)
    {
        _currentThickness = segment.Thickness;
        _showThicknessDialog = true;
        StateHasChanged();
    }
    
    private void StartDrag(PointerEventArgs e, VesselPoint point)
    {
        _draggedPoint = point;
    }

    private async Task HandleDrag(PointerEventArgs e)
    {
        if (_draggedPoint == null) return;
    
        var rect = await JsRuntime.InvokeAsync<BoundingClientRect>(
            "getBoundingClientRect", _imageContainer);
    
        _draggedPoint.X = (int)(e.ClientX - rect.Left);
        _draggedPoint.Y = (int)(e.ClientY - rect.Top);
    
        // Update connected segments
        UpdateConnectedSegments(_draggedPoint);
        StateHasChanged();
    }

    private void EndDrag()
    {
        _draggedPoint = null;
    }

    private void UpdateConnectedSegments(VesselPoint point)
    {
        foreach (var segment in _currentVesselAnnotation.Segments)
        {
            if (segment.StartPoint == point || segment.EndPoint == point)
            {
                // Force UI update for this segment
            }
        }
    }

    // JS interop struct
    private struct BoundingClientRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
    }

    [Inject] private IJSRuntime JsRuntime { get; set; } = default!;
}
